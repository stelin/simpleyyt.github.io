---
title: 'Mysql锁机制'
layout: post
tags:
  - mysql
  - 数据存储
category: 数据存储
---


mysql各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。

**行级锁**

行级锁定是目前各大数据库管理软件所实现的锁定颗粒度最小的,所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。 

但是由于锁定资源的颗粒度很小，所以每次获取锁和释放锁消耗的资源也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。

**表级锁**

表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。 

当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度较低。

**页级锁**

页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。 

在MySQL数据库中，使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎，而使用行级锁定的主要是Innodb存储引擎和NDBCluster存储引擎，页级锁定主要是BerkeleyDB存储引擎的锁定方式。

<!--more-->

### 锁机制原理

Innodb的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，Innodb也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。

- 共享锁，可以再加一个共享锁，不过不能加排他锁。 
- 排它锁，就在表上添加意向共享锁或意向排他锁。 
- 意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。


Innodb的锁定则是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记锁定信息而实现的。Innodb的这种锁定实现方式被称为“NEXT-KEYlocking”（间隙锁），因为Query执行过程中通过过范围查找，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。

间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。

除了间隙锁给Innodb带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：

- 当Query无法利用索引的时候，会放弃行级别锁定而改用表级别的锁定
- 当Quuery使用的索引并不包含所有过滤条件的时候，间隙锁会锁定不包含的记录，而不是具体的索引键
- 当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定

**Innodb锁优化**

> **行锁优化**
> - 尽可能让所有的数据检索都通过索引来完成，从而避免Innodb因为无法通过索引键加锁而升级为表级锁定；
> - 合理设计索引，让Innodb在索引键上面加锁尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；
> - 尽可能减少基于范围的数据检索过滤条件，避免间隙锁带来的负面影响而锁定了不该锁定的记录；
> - 尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
> - 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本；
> 
> **死锁优化**
> - 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁； 
> - 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率； 
> - 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

## 行锁

在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。

发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

> **避免死锁**
> 1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 
> 2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率； 
> 3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
   

## 表锁

表锁分为表共享读锁（共享锁）与表独占写锁（排他锁）

共享锁(Share Lock)又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。 

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。 

共享锁: SELECT ... LOCK IN SHARE MODE; 

在查询语句后面增加LOCK IN SHARE MODE， Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

排他锁（exclusive Lock）又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的锁。获准排他锁的事务既能读数据，又能修改数据。 

排它锁: SELECT ... FOR UPDATE; **

在查询语句后面增加FOR UPDATE， Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。

   

## 意向锁

意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁 

意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。 

## 锁资源

**表锁**


```python
mysql> show status like 'table%';
+----------------------------+---------+
| Variable_name              | Value   |
+----------------------------+---------+
| Table_locks_immediate      | 100     |
| Table_locks_waited         | 11      |
+----------------------------+---------+
```

这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：

- Table_locks_immediate：产生表级锁定的次数；
- Table_locks_waited：出现表级锁定争用而发生等待的次数；

**行锁**


```python
mysql> show status like 'InnoDB_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0     |
| InnoDB_row_lock_time          | 0     |
| InnoDB_row_lock_time_avg      | 0     |
| InnoDB_row_lock_time_max      | 0     |
| InnoDB_row_lock_waits         | 0     |
+-------------------------------+-------+
```

对各个状态量的说明如下：

- InnoDB_row_lock_current_waits：当前正在等待锁定的数量；
- InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；
- InnoDB_row_lock_time_avg：每次等待所花平均时间；
- InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
- InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；


如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。
锁冲突的表、数据行等，并分析锁争用的原因。具体方法如下：


```python
mysql> create table InnoDB_monitor(a INT) engine=InnoDB;

//然后就可以用下面的语句来进行查看：
mysql> show engine InnoDB status;

//监视器可以通过发出下列语句来停止查看：
mysql> drop table InnoDB_monitor;
```


## 实例

**行锁定**


| Session1	| Session2|
| --- | --- |
|set autocommit=0|	set autocommit=0|
|update test set b = ‘b1’ where a = 1; 更新但不提交||
|–|	update test set b = ‘b1’ where a = 1; 被阻塞，等待|
|commit; 提交|	–|
|–|	update test set b = ‘b1’ where a = 1; 解除阻塞|

**无索引升级为表锁**

| Session1	| Session2|
| --- | --- |
| update test set b = ‘2’ where b = 2000;| update test set b = ‘3’ where b = 3000;阻塞，等待| 
| commit;	| –| 
| –	| update test set b = ‘3’ where b = 3000;解除阻塞，完成更新| 

**间隙锁**

| Session1	| Session2|
| --- | --- |
|select * from test; update test set b = a * 100 where a < 4 and a > 1;|–|
|–	|mysql> insert into test values(2,’200’);被阻塞，等待|
|commit;	|–|
|–	|insert into test values(2,’200’);Query OK, 1 row affected (38.68 sec)|

**死锁示**

| Session1	| Session2|
| --- | --- |
|update t1 set id = 110 where id = 11;|–|
|–|	update t2 set id = 210 where id = 21;|
|update t2 set id=2100 where id=21;阻塞，等待session2释放|–|
|–	|update t1 set id=1100 where id=11; 阻塞，等待session1释放|
|两个 session 互相等等待对方的资源释放之后才能释放自己的资源,造成了死锁|–|








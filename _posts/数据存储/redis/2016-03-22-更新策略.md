---
title: '缓存技巧之更新策略(二)'
layout: post
tags:
  - redis
  - 缓存
  - 数据存储
category: 数据存储
---

缓存三大更新策略，算法剔除，主动更新，超时剔除。

<!--more-->


| 策略 | 一致性 | 维护成本 |
| --- | --- | --- |
| LRU/LIRS/FIFO算法剔除 | 最差 | 低  |
| 超时剔除 | 较差 | 较低 |
| 主动更新 | 强 | 高 |

## LRU/LFU/FIFO算法剔除

**使用场景**
例如：Memcache使用的是LRU，具体Memcache如何实现的，这里就不在赘述了，网上资料多的是。
例如：Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的更新策略。


| 配置名称 | 含义 | 淘汰策略 |
| --- | --- | --- |
| maxmemory | 最大可用内存 | 不使用该配置，也就对内存使用无限制 |
| maxmemory-policy | 内存不够时,淘汰策略 | volatile-lru |

volatile-lru -> 用lru算法删除过期的键值
allkeys-lru -> 用lru算法删除所有键值
volatile-random -> 随机删除过期的键值
allkeys-random -> 随机删除任何键值
volatile-ttl -> 删除最近要到期的键值
noeviction -> 不删除键，只返回一个错误

**一致性**
可以想象，要清理哪些数据，不是由开发者决定（只能决定大致方向：策略算法），数据的一致性是最差的。

**维护成本**
这些算法不需要开发者自己来实现，通常只需要配置最大maxmemory和对应的策略即可。成本最低

## 超时剔除
**使用场景**
就是我们通常做的缓存数据过期时间设置，例如redis和memcache都提供了expire这样的API，来设置K-V的过期时间。

**一致性**
一段时间内（取决于过期时间）存在数据一致性问题，即缓存数据和真实数据源数据不一致。
 
**维护成本**
用户的维护成本不是很高，只需要设置expire过期时间即可（前提是你的业务允许这段时间可能发生的数据不一致）。

## 主动更新

**使用场景**
业务对于数据的一致性要求很高，需要在真实数据更新后，立即更新缓存数据。

**一致性**
可以想象一致性最高（几乎接近强一致），但是有个问题：如果主动更新发生了问题，那么这条数据很可能很长时间不会更新了
 
**维护成本**
相当高，用户需要自己来完成更新（需要一定量的代码，从某种程度上加大了系统的复杂性），需要自己检查数据是否真的更新了之类的工作。





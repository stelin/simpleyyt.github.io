---
title: '微服务之熔断'
layout: post
tags:
  - 微服务
  - 分布式
category: 架构
---

	初中物理我们学习过电流通过保险丝会发热，超过一定的温度就会烧断，这样可以防止家用电器烧坏。这个原理同样适用分布式应用。
	
- 隔离

	在传统的服务设计中，服务都打包发布在一台服务器上，对于高流量的模式下，可能因为某个服务不可用，使整个服务都崩溃导致雪崩效应。为了减少雪崩发生的几率，采用分而治之的策略，把服务分组发布相互减少影响。
	
- 限流

	客户端发送过的请求数量太多，可能导致服务崩溃，因此为了保证服务可用，我们会对服务进行监控，通过事先的压力测试设定服务最大的阙值，超过该阙值则直接返回。
	
- 降级

	分布式服务，每个服务的级别不一样，对于在资源不充足的情况下，为了保证高级别服务继续服务，需要对低级别服务做出牺牲，把低级别的服务出让资源，或者改服务直接下线。
<!--more-->

## 名词解释

> consumer表示服务调用方 
provider标示服务提供方

## 超时

在接口调用过程中，consumer调用provider的时候，provider在响应的时候，有可能会慢，如果provider 10s响应，那么consumer也会至少10s才响应。如果这种情况频度很高，那么就会整体降低consumer端服务的性能。
这种响应时间慢的症状，从底层系统一直涌到最上层，造成整个链路的超时。
	所以，consumer不可能无限制地等待provider接口的返回，会设置一个时间阈值，如果超过了这个时间阈值，就不继续等待。
	这个超时时间选取，一般看provider正常响应时间是多少，再追加一个buffer即可。
## 重试
超时时间的配置是为了保护服务，避免consumer服务因为provider 响应慢而也变得响应很慢，这样consumer可以尽量保持原有的性能。
但是也有可能provider只是偶尔抖动，那么超时后直接放弃，不做后续处理，就会导致当前请求错误，也会带来业务方面的损失。
重试可以考虑切换一台机器来进行调用，因为原来机器可能由于临时负载高而性能下降，重试会更加剧其性能问题，而换一台机器，得到更快返回的概率也更大一些。

> **幂等**
> 如果允许consumer重试，那么provider就要能够做到幂等。即，同一个请求被consumer多次调用，对provider产生的影响是一致的。而且这个幂等应该是服务级别的，而不是某台机器层面的，重试调用任何一台机器，都应该做到幂等。

## 熔断

熔断的设计主要参考了hystrix的做法。其中最重要的是三个模块：熔断请求判断算法、熔断恢复机制、熔断报警。

 - 熔断请求判断机制算法：使用无锁循环队列计数，每个熔断器默认维护10个bucket，每1秒一个bucket，每个blucket记录请求的成功、失败、超时、拒绝的状态，默认错误超过50%且10秒内超过20个请求进行中断拦截。
 
 - 熔断恢复：对于被熔断的请求，每隔5s允许部分请求通过，若请求都是健康的（RT<250ms）则对请求健康恢复。

 - 熔断报警：对于熔断的请求打日志，异常请求超过某些设定则报警

## 限流

上面策略都是consumer针对provider出现各种情况而设计的。而provider有时候也要防范来自consumer的流量突变问题。provider端，需要根据consumer的重要程度，以及平时的QPS大小，来给每个consumer设置一个流量上线，同一时间内只会给A consumer提供N个线程支持，超过限制则等待或者直接拒绝。

### 隔离
provider可以对consumer来的流量进行限流，防止provider被拖垮。 
同样，consumer 也需要对调用provider的线程资源进行隔离。 这样可以确保调用某个provider逻辑不会耗光整个consumer的线程池资源。

> 1. 线程池隔离模式：使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理）

> 2. 信号量隔离模式：使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃改类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）

### 降级
降级服务既可以代码自动判断，也可以人工根据突发情况切换。

**consumer端**

consumer 如果发现某个provider出现异常情况，比如，经常超时(可能是熔断引起的降级)，数据错误，这是，consumer可以采取一定的策略，降级provider的逻辑，基本的有直接返回固定的数据。

**provider端**

当provider 发现流量激增的时候，为了保护自身的稳定性，也可能考虑降级服务。 
比如，1，直接给consumer返回固定数据，2，需要实时写入数据库的，先缓存到队列里，异步写入数据库。




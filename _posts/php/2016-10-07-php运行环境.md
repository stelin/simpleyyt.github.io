---
layout: post
title:  "php运行环境"
date:   2016-10-07
categories: [php]
---

## 1. 运行环境

### 1.1 LNMP

&#160; &#160; &#160; &#160;LNMP代表的就是：Linux系统下Nginx+MySQL(MongoDB)+PHP这种网站服务器架构,这几种软件均为免费开源软件，组合到一起，成为一个免费、高效、扩展性强的网站服务系统。

- Linux是一套免费使用和自由传播的类Unix操作系统，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora等。
- Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。
- MySQL是一个关系型数据库管理系统。MongoDB是一个基于分布式文件存储的非关系型数据库。
- PHP是一种在服务器端执行的脚本语言。


### 1.2 运行模式

#### 1.2.1 CGI

&#160; &#160; &#160; &#160;全称:common gateway interface,通用网关接口，用户将web server传来的数据格式化成标准格式，方便CGI程序的编写者。就是一种网络数据传输协议（json）。

> web server(nginx)只是内容的分发者。比如，如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。Nginx会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。

> 当web server收到/index.php这个请求后，会启动对应的CGI程序格式化数据格式，将数据和请求信息传给PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器

#### 1.2.2 Fastcgi
   
&#160; &#160; &#160; &#160;Fastcgi是用来提高CGI程序性能的,fastcgi其实就是实现cgi的程序 标准的CGI对每个请求都会执行上面这些步骤，所以处理每个时间的时间会比较长。这明显不合理嘛！Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。

#### 1.2.3 PHP-CGI

&#160; &#160; &#160; &#160;PHP-CGI是PHP自带的FastCGI管理器。PHP-CGI的不足：

- php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。
- 直接杀死php-cgi进程，php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。）

#### 1.2.4 phpfpm 

是一个实现了Fastcgi的程序，被PHP官方收了,php5.3以后的版本安装都默认安装fpm

## 2. 调试

### 2.1 nginx日志

* *.access.log: 访问日志
* *.error.log: 错误日志

### 2.2 php日志

- php_errors.log: PHP运行时异常、语法错误等
- www.log.slow: 慢执行日志
- php-fpm.log: php-fpm运行状态日志

### 2.3 业务日志

业务记录的运行相关日志比如notice和application

### 2.4 输出信息

&#160; &#160; &#160; &#160;有时需要打印变量数据调试代码，可以使用以下函数输出: var_dump($expression), var_export($expression, $return), print_r($expression, $return)，有时候会紧跟着die(1)终止程序执行。

``` php
<?php
$a = array(
    1,
    2,
    array(
        "a",
        "b",
        "c"
    )
);
var_dump($a);
die(1);
$a[] = 3;
var_dump($a);
```
输出结果如下:

```php
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  array(3) {
    [0]=>
    string(1) "a"
    [1]=>
    string(1) "b"
    [2]=>
    string(1) "c"
  }
}
```



* 目录
{:toc #cntNav}





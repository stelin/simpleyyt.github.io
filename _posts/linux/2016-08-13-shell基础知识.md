---
layout: post
title:  "shell基础知识"
date:   2016-08-13
categories: [linux]
---

# shell基础知识

## 命令的语法分析
&nbsp;&nbsp;Linux下的各种shell的主要区别在于命令行的语法。对于一些普通的命令，各个shell版本的语法基本相同，只有在编写一个shell脚本或者使用一些shell高级特性的时候，各个版本shell的差异才会显示出来。    
&nbsp;&nbsp;shell语法分析是指shell对命令的扫描处理过程，也就是，把命令或者用户输入的内容分解成要处理的各个部分的操作。在Linux系统下，shell语法分析包含很多内容，如重定向、文件名扩展和管道等。本节以bash为例，介绍shell命令的语法分析     

## 命令格式
&nbsp;&nbsp;用户登录系统后，shell命令行启动。shell遵循一定的语法格式将用户输入的命令进行分析解释并传递给系统内核。shell命令的一般格式为：


```
command [options] [arguments]
```

其中，    

- command：表示命令的名称。
- options：表示命令的选项。
- arguments：表示命令的参数。     
根据习惯，我们一般把具有以上格式的字符串称为命令行。命令行是用户与shell之间对话的基本单位。在命令行中，选项是包含一个或多个字母的代码，主要用于改变命令的执行方式。一般在选项前面有一个“-”符号，用于区别参数。例如：     


```
[root@WEBServer ～]#ls -a
```

ls命令加上-a选项后，列出当前目录下的所有文件（包含隐藏文件）。如果ls不加“-a”选项，则仅仅显示当前目录下的文件名和目录（不显示隐藏文件）。     

一般命令都有很多选项，可以单独列出它们，也可以在“-”后面把需要的选项都列出来，例如：

```
ls–a –l
ls–al
```



很多命令都可以接受参数。参数就是在选项后面紧跟的一个或多个字符串，这些字符串指定命令的操作对象，如文件或者目录。例如，要显示/etc目录下的所有文件及信息，可用以下命令。      


```
[root@WEBServer ～]#ls –al  /etc
```

特殊情况下，有些命令可以不带参数，例如ls命令，而有些必须带参数。当参数不够时，shell就会给出错误提示。例如，mv命令至少需要两个参数。       


```
[root@WEBServer ～]#mv  mylinux1.txt  mylinux.txt
```

在shell的一个命令行中，还可以输入多个命令，用分号将各个命令分开，例如：


```
[root@WEBServer ～]#ls –al;cp mylinux1.txt  mylinux2.txt
```

相反，也可以在多行中输入一个命令，用“\”将一个命令持续到下一行。      


```
[root@WEBServer ～]#cp –i \
>mylinux1.txt \
>mylinux2.txt
```

## 通配符
&nbsp;&nbsp;通配符主要是为了方便用户对文件或者目录的描述，例如，当用户仅仅需要以“.sh”结尾的文件时，使用通配符就能很方便地实现。各个版本的shell都有通配符，这些通配符是一些特殊字符，用户可以在命令行的参数中使用这些字符，进行文件名或者路径名的匹配。shell将把与命令行中指定的匹配规则符合的所有文件名或者路径名作为命令的参数，然后执行这个命令。      

bash中常用的通配符有“*”、“?”、“[]”。      

（1）“*”——匹配任意一个或多个字符        

例如：       


```
[root@WEBServer ～]#ls *.txt
```

这条命令列出当前目录中所有以“.txt”结尾的文件（除去以“.”开头的文件）。      


```
[root@WEBServer ～]#cp doc/* /opt
```

这条命令表示将doc目录下的所有文件（除去以“.”开头的文件）复制到/opt目录下。     


```
[root@WEBServer ～]#ls –al /etc/*/*.conf
```

这条命令列出/etc目录的子目录下所有以“.conf”结尾的文件。在/etc目录下以“.conf”结尾的文件将不会列出。        

（2）“?”——匹配任意单一字符        

例如：      


```
[root@WEBServer ～]#ls ab?.txt
```

这条命令列出当前目录下以ab开头，随后一个字母是任意字符，接着以“.txt”结尾的文件。          


```
[root@WEBServer ～]#ls ab??.txt
```

这条命令列出当前目录下以ab开头，随后的两个字母是任意字符，接着以“.txt”结尾的文件。       

（3）“[]”——匹配任何包含在方括号内的单字符      

例如：     


```
[root@WEBServer ～]#ls /dev/sda[12345]
/dev/sda1  /dev/sda2  /dev/sda3  /dev/sda4  /dev/sda5
```

上面的命令列出了在/dev目录下以sda开头，第4个字符是1、2、3、4或5的所有文件。


```
[root@WEBServer ～]#ls /dev/sda[1-5]
```

在方括号中“1-5”给出了匹配的范围，与上面一条命令完全等效。

（4）通配符的组合使用         

在Linux下，通配符也可以组合使用，例如：


```
[root@WEBServer ～]#ls [0-9]?.conf
```

这条命令列出当前目录下以数字开头，随后一个是任意字符，接着以“.conf”结尾的所有文件。


```
[root@WEBServer ～]#ls [xyz]*.txt
```

这条命令列出当前目录下以x、y或z开头，最后以“.txt”结尾的文件。

## 重定向
&nbsp;&nbsp;Linux下系统打开3个文件，即标准输入、标准输出和标准错误输出。用户的shell将键盘设为默认的标准输入，默认的标准输出和标准错误输出为屏幕。也就是，用户从键盘输入命令，然后将结果和错误消息输出到屏幕。       

&nbsp;&nbsp;所谓的重定向，就是不使用系统默认的标准输入/输出，而是重新指定，因此重定向分为输入重定向、输出重定向和错误输出重定向。要实现重定向就需要了解重定向操作符，shell就是根据重定向操作符来决定重定向操作的。

（1）输入重定向        

输入重定向用于改变命令的输入源，利用输入重定向，就可以将一个文件的内容作为命令的输入，而不从键盘输入。        

用于输入重定向的操作符有“<”和“<<”。例如：


```
[root@WEBServer ～]#wc</etc/shadow
40   40 1169
```

这里用wc命令统计输入给它的文件/etc/inittab的行数、单词数和字符数。       

还有一种输入重定向操作符“<<”。这种重定向告诉shell，当前命令的标准输入为来自命令行中一对分隔号之间的内容。例如：


```
[root@WEBServer ～]#wc<< aa
> # Default runlevel. The runlevels used by RHS are:
> #   0 - halt (Do NOT set initdefault to this)
> #   1 - Single user mode
> #   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
> #   3 - Full multiuser mode
> #   4 - unused
> #   5 - X11
> #   6 - reboot (Do NOT set initdefault to this)
>aa
8  65 303
```

上面的命令将一对分隔号aa之间的内容作为wc命令的输入。分隔号可以是任意字符。shell将在第一个分隔号后开始读取内容，直到出现另一个分隔号读取结束，然后将内容送给wc命令处理。

（2）输出重定向            

输出重定向不是将命令的输出结果在屏幕输出，而是输出到一个指定文件中。      

在Linux下输出重定向用得很多。例如，某个命令的输出很长，一个屏幕无法显示完毕，这时可以将命令的输出指定到一个文件，然后用more命令查看这个文件，从而得到命令输出的完整信息。        

用于输出重定向的操作符有“>”和“>>”。例如：


```
[root@WEBServer ～]#ps –ef >ps.txt
```

这条命令将ps –ef输出的系统运行进程信息全部输入到了ps.txt文件，而不输出到屏幕，可以用more命令查看ps.txt文件中系统运行的进程信息。


```
[root@WEBServer ～]#more file1 file2 file3 >file
```

其中，more命令用于查看文件的内容，上面的命令是将file1、file2和file3的内容全部输出到file文件中，类似于文件内容的合并。          

如果在“>”后面指定的文件不存在，shell就会自动重建一个；如果文件存在，那么这个文件原有的内容将被覆盖；如果不想覆盖存在的文件，可以使用“>>”操作符。例如：


```
[root@WEBServer ～]#ls –al /etc/* >>/root/install.log
```

这条命令将/etc目录及其子目录下的所有文件信息追加到/root/install.log文件的后面。/root/install.log文件原来的内容仍然存在。

（3）错误重定向       

错误重定向和标准输出重定向一样，可以使用操作符“2>”和“2>>”实现对错误输出的重定向。例如：


```
[root@WEBServer ～]#tar zxvf text.tar.gz 2> error.txt
```

其中，tar是打包命令，可以在屏幕上看到tar的解压过程。如果“text.tar.gz”是个损坏的压缩包，就会把错误消息输出到error.txt文件。

## 管道
管道可以把很多命令连接起来，可以把第1个命令的输入当作第2个命令的输出，第2个命令的输出当作第3个命令的输入，依此类推。因此，管道的作用就是把一个命令的输出当作下一个命令的输入，而不经过任何中间文件。    

通过管道符“|”可以建立管道连接，例如：


```
[root@WEBServer ～]#ls -al /etc/* |more
```

这条命令表示将/etc目录以及子目录下的所有文件分屏显示。


```
[root@WEBServer ～]#ps -ef|grep httpd|wc –l
```

这个命令用于查看系统中正在运行的httpd进程，并统计httpd的进程数。

5．shell中的引用          
在bash中有很多特殊字符，这些字符本身就具有特殊含义。如果在shell的参数中使用它们，就会出现问题。Linux中使用了“引用”技术来忽略这些字符的特殊含义，引用技术就是通知shell将这些特殊字符当作普通字符处理。shell中用于引用的字符有转义字符“\”、单引号“'”、双引号“""”。

（1）转义字符“\”           

如果将“\”放到特殊字符前面，shell就忽略这些特殊字符的原有含义，把它们当作普通字符对待，例如：


```
[root@WEBServer ～]#ls
abc?*  C:\backup
[root@WEBServer ～]#mv abc\?\*  abc
[root@WEBServer ～]#mv C\:\\backup backup
```

上面是将abc?*重命名为abc，将C:\backup重命名为backup。因为文件名中包含特殊字符，所以都使用了转义字符“\”。

（2）单引号“'”        

如果将字符串放到一对单引号之间，那么字符串中所有字符的特殊含义将被忽略，例如：


```
[root@WEBServer ～]#mv C\:\\backup backup
[root@WEBServer ～]#mv 'C:\backup'  backup
```

上面两条命令完全等效。

（3）双引号“""”      

双引号的引用与单引号基本相同，包含在双引号内的大部分特殊字符可以当作普通字符处理，但是仍有一些特殊字符即使用双引号括起来，也仍然保留自己的特殊含义，比如“$”、“\”和“`”。


```
[root@WEBServer ～]#str="The \$SHELL Current shell is $SHELL"
[root@WEBServer ～]#str1="\$$SHELL"
[root@WEBServer ～]#echo $str
The $SHELL Current shell is /bin/bash
[root@WEBServer ～]#echo $str1
$/bin/bash
```

从上面的输出可以看出，“$”和“\”在双引号内仍然保留了特殊含义。


```
[root@WEBServer ～]# str="This hostname is `hostname`" 
[root@WEBServer ～]# echo $str
This hostname is WEBServer
```

上面的输出中，字符“`”在双引号中也保留了自己的特殊含义。

## 自动补全命令行      
自动补全命令行是bash一个简单而且实用的功能，自动补全命令行也就是在输入命令时不必把命令输全，shell就能智能判断用户所要输入的命令。      

当用户输入某个命令的一部分后，按Tab键，shell就会根据系统环境变量信息提示出与用户输入命令相似的所有命令和文件，例如：       


```
[root@WEBServer ～]# if<按Tab键>
if    ifcfg    ifconfig   ifdown    ifenslave  ifnames    ifrename   ifup  
[root@WEBServer ～]# if
```

可以从上面看到，用户输入“if”后按Tab键，即可显示以“if”为前缀的所有命令和文件。如果需要的是ifconfig命令，那么只须再次输入“co”，然后按Tab键，shell就能补全命令。       

如果我们要进入一个很深的目录中，并且每个目录的名字又很长，此时利用bash的自动补全功能，就再好不过了。





* 目录
{:toc #cntNav}



